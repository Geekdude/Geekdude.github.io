<html>
<head>
<meta charset="utf-8">
<title>Dungeons and Dragons</title>
<link rel="shortcut icon" href="favicon.ico" />
<!-- include all javascript source files -->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type="text/javascript" src="js/sylvester.js"></script>
<script type="text/javascript" src="js/math.js"></script>
<script type="text/javascript" src="js/glUtils.js"></script>
<script type="text/javascript" src="js/objLoader.js"></script>
<script type="text/javascript" src="js/light.js"></script>
<script type="text/javascript" src="js/arcball.js"></script>
<script type="text/javascript" src="js/firstperson.js"></script>
<script type="text/javascript" src="js/demo.js"></script>
<script type="text/javascript" src="js/main.js"></script>
<style>
    body {
        margin: 0;
    }
    #glpanel {
        position: absolute;
        width: 100%;
        opacity: 0.8;
    {
</style>
</head>
<body>
<div id="glarea">
    <div id="glpanel">
        <button id="changeCamera" type="button"></button>
        <select id="qualitySelect">
            <option value= '0'>Low</option>
            <option selected="selected" value= '1'>Medium</option>
            <option value= '2'>High</option>
            <option value= '3'>Ultra</option>
        </select>
        <button onclick="window.location.href='README.html';">Go to Readme</button>
        FPS: <span id="fps"></span>
        AVG FPS: <span id="avg"></span>
    </div>
    <canvas id="glcanvas">canvas not supported</canvas>
</div>

<!-- Vertex Shader -->
<script id="VertexShaderSkybox" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position
    in vec2 aTexture;  // Texture coordinate

    out vec3 vPosition;

    uniform mat4 uMVMatrix;   //modelviewmatrix
    uniform mat4 uPMatrix;    //projectionmatrix

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);

        // Pass the vertex coordinates
        vPosition = aPosition;
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderSkybox" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    layout (location = 0) out vec4 FragColor;
    layout (location = 1) out vec4 BrightColor;

    in vec3 vPosition;

    uniform samplerCube uSkybox;

    void main(void){
        // Flip the x coordinate since cube map is viewed from the inside for a skybox.
        vec3 texture_coord = vec3(-vPosition.x, vPosition.yz);

        // Get the texel color
        vec4 texelColor = texture(uSkybox, texture_coord);

        // Set the fragment color to the texture color.
        FragColor = texelColor;

        // Check for brightness
        float brightness = dot(texelColor.rgb, vec3(0.2126, 0.7152, 0.0722));
        if (brightness > 0.95)
            BrightColor = vec4(texelColor);
        else
            BrightColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
</script>

<!-- Vertex Shader -->
<script id="VertexShaderShadow" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position

    uniform mat4 uMVMatrix;   //modelviewmatrix
    uniform mat4 uPMatrix;    //projectionmatrix

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderShadow" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    void main(void) {
    }
</script>

<!-- Vertex Shader -->
<script id="VertexShaderPhong" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position
    in vec3 aNormal;   // Normals
    in vec2 aTexture;  // Texture coordinate

    out vec3 vPosition;
    out vec3 vNormal;
    out vec2 vTexture;
    out vec3 vLightPosition[16];
    out vec4 vPositionFromLight[2];

    uniform mat4 uMVMatrix;   //modelviewmatrix
    uniform mat4 uVMatrix;    //viewmatrix
    uniform mat4 uPMatrix;    //projectionmatrix

    uniform mat4 uLightMatrix0;   //modelviewmatrix
    uniform mat4 uLightMatrix1;   //modelviewmatrix

    uniform vec3 uLightPosition[16];

    const int NUM_LIGHTS = 16;

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);

        // Pass the vertex coordinates
        vPosition = vec3(uMVMatrix * vec4(aPosition, 1.0));

        // Pass the normal coordinates
        vNormal = normalize(mat3(uMVMatrix) * aNormal);

        // Pass the texture coordinates
        vTexture = aTexture;

        // For each light
        for (int i = 0; i < NUM_LIGHTS; i++) {
            vLightPosition[i] = vec3(uVMatrix * vec4(uLightPosition[i], 1.0));
        }

        // For each shadow light Calculate position from light
        vPositionFromLight[0] = uLightMatrix0 * vec4(aPosition, 1.0);
        vPositionFromLight[1] = uLightMatrix1 * vec4(aPosition, 1.0);
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderPhong" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    layout (location = 0) out vec4 FragColor;
    layout (location = 1) out vec4 BrightColor;

    in vec3 vPosition;
    in vec3 vNormal;
    in vec2 vTexture;
    in vec3 vLightPosition[16];
    in vec4 vPositionFromLight[2];

    uniform sampler2D uTexture;

    uniform sampler2D uShadow0;
    uniform sampler2D uShadow1;

    // Material co-efficients.
    uniform vec3 ambient_k;
    uniform vec3 diffuse_k;
    uniform vec3 specular_k;
    uniform float transparency;
    uniform float specular_exponent;

    // Light uniforms
    uniform vec3 uLightAmbient[16];
    uniform vec3 uLightDiffuse[16];
    uniform vec3 uLightSpecular[16];
    uniform bool uLightEnabled[16];

    uniform bool shadowEnabled;

    const int NUM_LIGHTS = 16;

    // Light and camera Position in eye space.
    vec3 cameraPosition = vec3(0.0, 0.0, 0.0);

    vec3 illumination = vec3(0);
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    vec3 color;

    float ShadowCalculation(vec4 fragPosLightSpace, sampler2D shadowTexture, vec3 L) {
        if (!shadowEnabled)
            return 0.0;

        // Perform perspective divide
        vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

        // Transform to [0,1] range
        projCoords = projCoords * 0.5 + 0.5;

        // Get the closest depth value from the light's perspective
        float closestDepth = texture(shadowTexture,  projCoords.xy).r;

        // Get the depth of current fragment from light's perspective
        float currentDepth = projCoords.z;

        // Calculate bias (based on depth map resolution and slope)
        float bias = max(0.005 * (1.0 - dot(vNormal, L)), 0.001);

        // Check to see if current fragment position is in shadow
        // Regular
        /* float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0; */

        // With PCF
        float shadow = 0.0;
        vec2 texelSize = 1.0 / vec2(textureSize(shadowTexture, 0));
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                float pcfDepth = texture(shadowTexture, projCoords.xy + vec2(x, y) * texelSize).r;
                shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
            }
        }
        shadow /= 9.0;

        // keep the shadow at 0.0 when outside the far_plane region of the light's frustrum
        if (projCoords.z > 1.0) {
            shadow = 0.0;
        }

        return shadow;
    }
    void main(void){
        // Get the texel color
        vec4 texelColor = texture(uTexture, vTexture);

        // Determine the viewing direction
        vec3 V = normalize(cameraPosition-vPosition);

        // For each light
        for (int i = 0; i < NUM_LIGHTS; i++) {
            // Is light enabled
            if (uLightEnabled[i] == true) {
                // Determine the light direction
                vec3 L = normalize(vLightPosition[i]-vPosition);

                // Calculate the light reflection direction.
                /* vec3 R = normalize(reflect(-vNormal, L)); */
                vec3 R = normalize(2.0*dot(vNormal,L)*vNormal-L);

                // Calculate the lighting components
                ambient = ambient_k * uLightAmbient[i];
                diffuse = texelColor.rgb * clamp(diffuse_k * uLightDiffuse[i] * max(dot(vNormal, L), 0.0), 0.0, 1.0);
                specular = clamp(specular_k * uLightSpecular[i] * pow(max(dot(R,V), 0.0), specular_exponent), 0.0, 1.0);

                float shadow = 0.0;
                if (i == 0) {
                    shadow = ShadowCalculation(vPositionFromLight[i], uShadow0, L);
                }
                if (i == 1) {
                    shadow = ShadowCalculation(vPositionFromLight[i], uShadow1, L);
                }

                // Combine components to get illumination
                illumination += clamp(ambient + (1.0 - shadow) * (diffuse + specular), 0.0, 1.0);
            }
        }

        // Set the fragment color to the texture color.
        FragColor.rgb = illumination;
        FragColor.a = transparency;
        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
</script>

<!-- Vertex Shader -->
<script id="VertexShaderBump" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position
    in vec3 aNormal;   // Normals
    in vec2 aTexture;  // Texture coordinate
    in vec3 aTangent;  // Tangent Buffer
    in vec3 aBitangent;  // Bitangent Buffer

    out vec3 vPosition;
    out vec3 vNormal;
    out vec2 vTexture;
    out vec3 vLightPosition[16];
    out vec4 vPositionFromLight[2];
    out mat3 TBN;

    uniform mat4 uMVMatrix;   //modelviewmatrix
    uniform mat4 uVMatrix;    //viewmatrix
    uniform mat4 uPMatrix;    //projectionmatrix

    uniform mat4 uLightMatrix0;   //modelviewmatrix
    uniform mat4 uLightMatrix1;   //modelviewmatrix

    uniform vec3 uLightPosition[16];

    const int NUM_LIGHTS = 16;

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = uPMatrix * uMVMatrix * vec4(aPosition, 1.0);

        // Pass the vertex coordinates
        vPosition = vec3(uMVMatrix * vec4(aPosition, 1.0));

        // Pass the normal coordinates
        vNormal = normalize(mat3(uMVMatrix) * aNormal);

        // Pass the texture coordinates
        vTexture = aTexture;

        // For each light
        for (int i = 0; i < NUM_LIGHTS; i++) {
            vLightPosition[i] = vec3(uVMatrix * vec4(uLightPosition[i], 1.0));
        }

        // For each shadow light Calculate position from light
        vPositionFromLight[0] = uLightMatrix0 * vec4(aPosition, 1.0);
        vPositionFromLight[1] = uLightMatrix1 * vec4(aPosition, 1.0);

        // Calculate TBN matrix
        vec3 T = normalize(mat3(uMVMatrix) * aTangent);
        vec3 B = normalize(mat3(uMVMatrix) * aBitangent);
        vec3 N = normalize(mat3(uMVMatrix) * aNormal);
        TBN = mat3(T, B, N);
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderBump" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    layout (location = 0) out vec4 FragColor;
    layout (location = 1) out vec4 BrightColor;

    in vec3 vPosition;
    in vec3 vNormal;
    in vec2 vTexture;
    in vec3 vLightPosition[16];
    in vec4 vPositionFromLight[2];
    in mat3 TBN;

    uniform sampler2D uTexture;
    uniform sampler2D uNormal;

    uniform sampler2D uShadow0;
    uniform sampler2D uShadow1;

    // Material co-efficients.
    uniform vec3 ambient_k;
    uniform vec3 diffuse_k;
    uniform vec3 specular_k;
    uniform float specular_exponent;

    // Light uniforms
    uniform vec3 uLightAmbient[16];
    uniform vec3 uLightDiffuse[16];
    uniform vec3 uLightSpecular[16];
    uniform bool uLightEnabled[16];

    uniform bool shadowEnabled;

    const int NUM_LIGHTS = 16;

    // Light and camera Position in eye space.
    vec3 cameraPosition = vec3(0.0, 0.0, 0.0);

    vec3 illumination = vec3(0);
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    vec3 color;

    float ShadowCalculation(vec4 fragPosLightSpace, sampler2D shadowTexture, vec3 L) {
        if (!shadowEnabled)
            return 0.0;

        // Perform perspective divide
        vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

        // Transform to [0,1] range
        projCoords = projCoords * 0.5 + 0.5;

        // Get the closest depth value from the light's perspective
        float closestDepth = texture(shadowTexture,  projCoords.xy).r;

        // Get the depth of current fragment from light's perspective
        float currentDepth = projCoords.z;

        // Calculate bias (based on depth map resolution and slope)
        float bias = max(0.005 * (1.0 - dot(vNormal, L)), 0.001);

        // Check to see if current fragment position is in shadow
        // Regular
        /* float shadow = currentDepth - bias > closestDepth  ? 1.0 : 0.0; */

        // With PCF
        float shadow = 0.0;
        vec2 texelSize = 1.0 / vec2(textureSize(shadowTexture, 0));
        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                float pcfDepth = texture(shadowTexture, projCoords.xy + vec2(x, y) * texelSize).r;
                shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
            }
        }
        shadow /= 9.0;

        // keep the shadow at 0.0 when outside the far_plane region of the light's frustrum
        if (projCoords.z > 1.0) {
            shadow = 0.0;
        }

        return shadow;
    }
    void main(void){
        // Get the texel color
        vec4 texelColor = texture(uTexture, vTexture);

        // Determine the viewing direction
        vec3 V = normalize(cameraPosition-vPosition);

        // Determine Normal
        vec3 normal = texture(uNormal, vTexture).rgb;
        normal = normalize(normal * 2.0 - 1.0);
        normal = normalize(TBN * normal);

        // For each light
        for (int i = 0; i < NUM_LIGHTS; i++) {
            // Is light enabled
            if (uLightEnabled[i] == true) {
                // Determine the light direction
                vec3 L = normalize(vLightPosition[i]-vPosition);

                // Calculate the light reflection direction.
                /* vec3 R = normalize(reflect(-vNormal, L)); */
                vec3 R = normalize(2.0*dot(normal,L)*normal-L);

                // Calculate the lighting components
                ambient = ambient_k * uLightAmbient[i];
                diffuse = texelColor.rgb * clamp(diffuse_k * uLightDiffuse[i] * max(dot(normal, L), 0.0), 0.0, 1.0);
                specular = clamp(specular_k * uLightSpecular[i] * pow(max(dot(R,V), 0.0), specular_exponent), 0.0, 1.0);

                float shadow = 0.0;
                if (i == 0) {
                    shadow = ShadowCalculation(vPositionFromLight[i], uShadow0, L);
                }
                if (i == 1) {
                    shadow = ShadowCalculation(vPositionFromLight[i], uShadow1, L);
                }

                // Combine components to get illumination
                illumination += clamp(ambient + (1.0 - shadow) * (diffuse + specular), 0.0, 1.0);
            }
        }

        // Set the fragment color to the texture color.
        FragColor = vec4(illumination.rgb, 1.0);
        BrightColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
</script>

<!-- Vertex Shader -->
<script id="VertexShaderBlur" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position
    in vec2 aTexture;  // Texture coordinate

    out vec2 vTexture;

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = vec4(aPosition, 1.0);

        // Pass the texture coordinates
        vTexture = aTexture;
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderBlur" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    layout (location = 0) out vec4 FragColor;

    in vec2 vTexture;

    uniform sampler2D uImage;

    uniform bool uHorizontal;
    float weight[5] = float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);

    void main(void) {
        // Get the size of a texel
        vec2 tex_offset = vec2(1.0) / vec2(textureSize(uImage, 0));

        vec3 texelColor = texture(uImage, vTexture).rgb * weight[0];

        // Blur the image
        if(uHorizontal)
        {
            for(int i = 1; i < 5; ++i)
            {
                texelColor += texture(uImage, vTexture + vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];
                texelColor += texture(uImage, vTexture - vec2(tex_offset.x * float(i), 0.0)).rgb * weight[i];
            }
        }
        else
        {
            for(int i = 1; i < 5; ++i)
            {
                texelColor += texture(uImage, vTexture + vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];
                texelColor += texture(uImage, vTexture - vec2(0.0, tex_offset.y * float(i))).rgb * weight[i];
            }
        }

        // Set the fragment color to the texture color.
        FragColor = vec4(texelColor, 1.0);
    }
</script>

<!-- Vertex Shader -->
<script id="VertexShaderQuad" type="x-shader/x-vertex"> #version 300 es
    in vec3 aPosition; // Vertex position
    in vec2 aTexture;  // Texture coordinate

    out vec2 vTexture;

    void main(void) {
        // Calculate the transformed vertex position
        gl_Position = vec4(aPosition, 1.0);

        // Pass the texture coordinates
        vTexture = aTexture;
    }
</script>

<!-- Fragment Shader -->
<script id="FragmentShaderQuad" type="x-shader/x-fragment"> #version 300 es
    #ifdef GL_OES_standard_derivatives
        #extension GL_OES_standard_derivatives : enable
    #endif

    precision mediump float;

    layout (location = 0) out vec4 FragColor;

    in vec2 vTexture;

    uniform sampler2D uScene;
    uniform sampler2D uBloom;

    uniform bool bloom;

    void main(void){
        // Get the texel colors
        vec4 sceneColor = texture(uScene, vTexture);
        vec3 bloomColor = texture(uBloom, vTexture).rgb;

        if (bloom)
            sceneColor.rgb += bloomColor.rgb;

        // Set the fragment color to the texture color.
        FragColor = sceneColor;
    }
</script>

<script>
    //call the main mesh Loading function; main.js
    executeMainLoop();
</script>

</body>
</html>
